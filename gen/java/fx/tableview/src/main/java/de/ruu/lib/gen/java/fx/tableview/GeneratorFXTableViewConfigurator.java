package de.ruu.lib.gen.java.fx.tableview;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaMethod;
import com.tngtech.archunit.core.domain.JavaType;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import de.ruu.lib.gen.GeneratorException;
import de.ruu.lib.gen.java.CompilationUnitFileWriter;
import de.ruu.lib.gen.java.GeneratorCodeBlock;
import de.ruu.lib.gen.java.context.CompilationUnitContext;
import de.ruu.lib.gen.java.element.method.GeneratorMethod;
import de.ruu.lib.gen.java.element.type.GeneratorClass;
import de.ruu.lib.gen.java.fx.bean.FXProperty;
import de.ruu.lib.gen.java.fx.bean.FXPropertyUtil;
import de.ruu.lib.gen.java.naming.ImportManager;
import de.ruu.lib.util.Strings;
import de.ruu.lib.util.Time;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.Property;
import javafx.beans.property.StringProperty;
import javafx.geometry.Pos;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.control.cell.CheckBoxTableCell;
import javafx.scene.control.cell.TextFieldTableCell;
import lombok.NonNull;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.Optional;

import static de.ruu.lib.archunit.Util.isCollection;
import static de.ruu.lib.archunit.Util.isPublic;
import static de.ruu.lib.gen.java.CompilationUnitFileWriter.writer;
import static de.ruu.lib.gen.java.GeneratorCodeBlock.codeBlokk;
import static de.ruu.lib.gen.java.Visibility.PRIVATE;
import static de.ruu.lib.gen.java.Visibility.PUBLIC;
import static de.ruu.lib.gen.java.context.CompilationUnitContext.context;
import static de.ruu.lib.gen.java.doc.GeneratorJavaDoc.javaDoc;
import static de.ruu.lib.gen.java.element.GeneratorModifiersClass.classModifiers;
import static de.ruu.lib.gen.java.element.GeneratorModifiersMethod.methodModifiers;
import static de.ruu.lib.gen.java.element.method.GeneratorMethod.method;
import static de.ruu.lib.gen.java.element.method.GeneratorParameter.parameter;
import static de.ruu.lib.gen.java.element.method.GeneratorParameters.parameters;
import static de.ruu.lib.gen.java.fx.bean.FXMapper.DeclaredTypeProcessor.importManagement;
import static de.ruu.lib.gen.java.fx.bean.FXMapper.mapFXPropertyToPrimitiveWrapper;
import static de.ruu.lib.gen.java.fx.bean.FXPropertyUtil.isNumericFXPropertyType;
import static de.ruu.lib.util.Constants.LS;
import static de.ruu.lib.util.Strings.firstLetterToUpperCase;

public class GeneratorFXTableViewConfigurator
{
	@NonNull private final String packageName;    // package name for target
	@NonNull private final String simpleFileName; // simple file name for target

	@NonNull private final JavaClass clazz;       // source

	@NonNull private CompilationUnitContext context;

	private final static String CREATE_COLUMN_METHOD_NAME_STATEMENT_PREFIX = "createColumn";

	public GeneratorFXTableViewConfigurator(
			@NonNull String packageName, @NonNull String simpleFileName, @NonNull JavaClass clazz)
	{
		this.packageName    = packageName;
		this.simpleFileName = simpleFileName;

		this.clazz          = clazz;

		context = context(packageName, simpleFileName);
	}

	public GeneratorFXTableViewConfigurator(
			@NonNull String packageName, @NonNull String simpleFileName, @NonNull Class<?> clazz)
	{
		this(packageName, simpleFileName, new ClassFileImporter().importClass(clazz));
	}

	/**
	 * Creates and executes {@link GeneratorClass} instance,
	 * <p>
	 * Configures javadoc, class modifier and class signature, then delegates to {@link #classCodeBlock()} for
	 * configuration of code block generator.
	 * <p>
	 * Finally writes generator output to java source file. Example:
	 *
	 * <pre>{@code
	 * package de.ruu.lib.gen.java.fx.tableview.demo;
	 *
	 * import javafx.scene.control.TableColumn;
	 * import javafx.scene.control.TableView;
	 * import javafx.scene.control.cell.CheckBoxTableCell;
	 * import javafx.scene.control.cell.TextFieldTableCell;
	 *
	 * /**                                                       // JAVADOC
	 *  * FXTableViewConfigurator {@link FXTableViewConfigurator}
	 *  * generated by {@link GeneratorFXTableViewConfigurator } at 2023.12.27 16:17:09:298
	 *  *{@literal /}
	 * public abstract class FXTableViewConfigurator             // CLASS SIGNATURE
	 * {                                                         // CLASS CODE BLOCK
	 *   static void configure(TableView<FXModelDemo> tableView) // TABLE VIEW CONFIGURATION METHOD
	 *   {                                                       // BLOCK OF COLUMN CONFIGURATION STATEMENTS
	 *     tableView.getColumns().add(createColumnAnInteger());  // COLUMN CONFIGURATION STATEMENT
	 *     tableView.getColumns().add(createColumnAString());    // COLUMN CONFIGURATION STATEMENT
	 *     tableView.getColumns().add(createColumnABoolean());   // COLUMN CONFIGURATION STATEMENT
	 *   }
	 *
	 *  private static TableColumn<FXModelDemo, Number> createColumnAnInteger() // COLUMN CONFIGURATION METHOD
	 *  {
	 *    TableColumn<FXModelDemo, Number> result = new TableColumn<>("anInteger");
	 *    result.setCellValueFactory(data -> data.getValue().anInteger());
	 *    result.setCellFactory(
	 *    tableColumn ->
	 *    {
	 *      TextFieldTableCell<FXModelDemo, Number> cell = new TextFieldTableCell<>();
	 *      cell.setAlignment(Pos.CENTER_RIGHT);
	 *      return cell;
	 *    });
	 *    return result;
	 *  }
	 *
	 *  private static TableColumn<FXModelDemo, String> createColumnAString()
	 *  {
	 *    TableColumn<FXModelDemo, String> result = new TableColumn<>("aString");
	 *    result.setCellValueFactory(data -> data.getValue().aString());
	 *    result.setCellFactory(TextFieldTableCell.forTableColumn());
	 *    return result;
	 *  }
	 *
	 * 	private static TableColumn<FXModelDemo, Boolean> createColumnABoolean()
	 * 	{
	 * 		TableColumn<FXModelDemo, Boolean> result = new TableColumn<>("aBoolean");
	 * 		result.setCellValueFactory(data -> data.getValue().aBoolean());
	 * 		result.setCellFactory(tableColumn -> new CheckBoxTableCell<>());
	 * 		return result;
	 * 	}
	 *
	 * }
	 * }</pre>
	 *
	 * @throws GeneratorException
	 * @throws IOException
	 */
	public void run() throws GeneratorException, IOException
	{
		GeneratorClass generator =
				GeneratorClass.classType(context, simpleFileName)
						.childNodesSeparator(LS)
						.javaDoc
						(
								javaDoc(context)
										.add("FXTableViewConfigurator {@link " + simpleFileName + "}")
										.add("<p>")
										.add("generated by {@link " + getClass().getName() + "} at " + Time.getSortableTimestamp())
						)
						.modifiers(classModifiers(context).visibility(PUBLIC).setAbstract(true))
						.codeBlock(classCodeBlock())
						;
		CompilationUnitFileWriter writer = writer(packageName, simpleFileName);
		writer.write(generator.generate().toString());
	}

	/**
	 * Creates code block generator for table view configurator. Code block consists of method for table
	 * view configuration and the configuration methods for each column.
	 *
	 * @return code block generator
	 */
	private GeneratorCodeBlock classCodeBlock()
	{
		GeneratorCodeBlock result = codeBlokk(context).childNodesSeparator(LS + LS);

		addGeneratorForTableViewConfigurationMethod(result);
		addGeneratorsForCreateColumnMethodCalls    (result);

		return result;
	}

	/**
	 * Creates method generator for table view configurator. Example:
	 *
	 * <pre>
	 * static void configure(TableView<FXModelDemo> tableView)
	 * {
	 * 	tableView.getColumns().add(createColumnAnInteger());
	 * 	tableView.getColumns().add(createColumnAString());
	 * 	tableView.getColumns().add(createColumnABoolean());
	 * }
	 * </pre>
	 *
	 * @param codeBlock to add generator output to
	 */
	private void addGeneratorForTableViewConfigurationMethod(GeneratorCodeBlock codeBlock)
	{
		String parameterName = "tableView";
		GeneratorMethod configure =
				method(context, "void", "configure")
						.modifiers(methodModifiers(context).setStatic(true).visibility(PUBLIC))
						.parameters(
								parameters(context)
										.add(
												parameter(
														context,
														context.importManager().useType(TableView.class.getName())
																+ "<" + context.importManager().useType(clazz.getFullName()) + ">",
														parameterName)))
						.childNodesSeparator(LS)
						.codeBlock(configureTableViewMethodCodeBlock(parameterName))
						;

		codeBlock.add(configure);
	}

	/**
	 * Creates method generators for configuration of each column. Example:
	 *
	 * <pre>
	 * private static TableColumn<FXModelDemo, String> createColumnAString()
	 * {
	 * 	TableColumn<FXModelDemo, String> result = new TableColumn<>("aString");
	 * 	result.setCellValueFactory(data -> data.getValue().aString());
	 * 	result.setCellFactory(TextFieldTableCell.forTableColumn());
	 * 	return result;
	 * }
	 * </pre>
	 *
	 * @param codeBlock to add generator output to
	 */
	private void addGeneratorsForCreateColumnMethodCalls(GeneratorCodeBlock result)
	{
		// generate create column statements
		for (JavaMethod method : clazz.getAllMethods())
		{
			if (isPublicAndReturnsFXProperty(method))
			{
				result
						.add
						(
								method
								(
										context,
										createColumnMethodReturnType(method),
										CREATE_COLUMN_METHOD_NAME_STATEMENT_PREFIX + Strings.firstLetterToUpperCase(method.getName())
								)
										.modifiers(methodModifiers(context).setStatic(true).visibility(PRIVATE))
										.childNodesSeparator(LS)
										.codeBlock(createColumnMethodCodeBlock(method))
						);
			}
		}
	}

	/**
	 * Creates code block generator for calls to each column configuration method. Example:
	 *
	 * <pre>
	 * tableView.getColumns().add(createColumnAnInteger());
	 * tableView.getColumns().add(createColumnAString());
	 * tableView.getColumns().add(createColumnABoolean());
	 * </pre>
	 *
	 * @param parameterName actual name of table view parameter
	 * @return generator for column configuration method calls
	 */
	private @NonNull GeneratorCodeBlock configureTableViewMethodCodeBlock(String parameterName)
	{
		GeneratorCodeBlock result = codeBlokk(context);
		result.childNodesSeparator(LS);

		// generate add column statements
		for (JavaMethod method : clazz.getAllMethods())
		{
			if (isPublicAndReturnsFXProperty(method))
			{
				result
						.add
						(
								parameterName
										+ ".getColumns().add("
										+ CREATE_COLUMN_METHOD_NAME_STATEMENT_PREFIX
										+ firstLetterToUpperCase(method.getName()) + "());"
						);
			}
		}

		return result;
	}

	/**
	 * Creates code block generator for column configuration method. Example:
	 *
	 * <pre>
	 * TableColumn<FXModelDemo, String> result = new TableColumn<>("aString");
	 * result.setCellValueFactory(data -> data.getValue().aString());
	 * result.setCellFactory(TextFieldTableCell.forTableColumn());
	 * return result;
	 * </pre>
	 *
	 * @param method java fx property method (see {@link FXProperty})
	 * @return generator for code block of column configuration method
	 */
	private @NonNull GeneratorCodeBlock createColumnMethodCodeBlock(JavaMethod method)
	{
		GeneratorCodeBlock result = codeBlokk(context);
		result.childNodesSeparator(LS);

		result.add
		(
				createColumnMethodReturnType(method)
						+ " result = "
						+      "new " + context.importManager().useType(TableColumn.class)
						+          "<>(\"" + method.getName() + "\");"
						+ LS
						+ "result.setCellValueFactory(" + createCellValueFactoryConfiguration(method) + ");"
						+ LS
						+ "result.setCellFactory(" + createCellFactoryConfiguration(method) + ");"
						+ LS
						+ "return result;"
		);

		return result;
	}

	private String createColumnMethodReturnType(JavaMethod method)
	{
		ImportManager importManager = context.importManager();

		return
			  importManager.useType(TableColumn.class)
			+ "<"
			+ importManager.useType(clazz.getFullName())
			+ ", "
			+ importManager.useType(createColumnMethodCellType(method))
			+ ">";
	}

	/**
	 * Example:
	 *
	 * <pre>
	 * //                                      v----v--- cell type
	 * private static TableColumn<FXModelDemo, String> createColumnAString()
	 * </pre>
	 *
	 * @param method
	 * @return
	 */
	private String createColumnMethodCellType(JavaMethod method)
	{
		JavaType      returnType     = method    .getReturnType();
		String        returnTypeName = returnType.getName();

		if      (returnTypeName.equals(ObjectProperty.class.getName() + "<" + BigDecimal.class.getName() + ">"))
		{
			return BigDecimal.class.getName();
		}
		else if (returnTypeName.equals(BooleanProperty.class.getName()))
		{
			return Boolean.class.getSimpleName();
		}
		else if (returnTypeName.equals(StringProperty.class.getName()))
		{
			return String.class.getSimpleName();
		}
		else
		{
			Optional<String> optionalPrimitive =
					mapFXPropertyToPrimitiveWrapper(returnType, importManagement(context));

			if (optionalPrimitive.isPresent())
			{
				String result = optionalPrimitive.get();

				if (isNumericFXPropertyType(returnType))
				{
					result = Number.class.getSimpleName();
				}

				return result;
			}
		}

		throw new IllegalStateException("unexpected method return type: " + method.getReturnType().getName());
	}

	/**
	 * Example:
	 * 
	 * <pre>
	 * //                         v-------------------------------v---cell value factory configuration
	 * result.setCellValueFactory(data -> data.getValue().aString());
	 * </pre>
	 * 
	 * @param method
	 * @return
	 */
	private String createCellValueFactoryConfiguration(JavaMethod method)
	{
		return "data -> data.getValue()." + method.getName() + "()";
	}

	/**
	 * Example:
	 * 
	 * <pre>
	 * //                    v---------------------------------v---cell factory configuration
	 * result.setCellFactory(TextFieldTableCell.forTableColumn());
	 * </pre>
	 *
	 * @param method
	 * @return
	 */
	private String createCellFactoryConfiguration(JavaMethod method)
	{
		JavaType methodReturnType = method.getReturnType();

		if      (isNumericFXPropertyType(methodReturnType))
		{
			return createNumericCellFactoryConfiguration(methodReturnType, Number.class);
		}
		else if (methodReturnType.getName().equals(
		         ObjectProperty.class.getName() + "<" + BigDecimal.class.getName() + ">"))
		{
			return createNumericCellFactoryConfiguration(methodReturnType, BigDecimal.class);
		}
		else if (FXPropertyUtil.isBooleanFXPropertyType(methodReturnType))
		{
			return "tableColumn -> new " + context.importManager().useType(CheckBoxTableCell.class) + "<>()";
		}

		return context.importManager().useType(TextFieldTableCell.class) + ".forTableColumn()";
	}

	private String createNumericCellFactoryConfiguration(JavaType methodReturnType, Class<?> numericType)
	{
		ImportManager importManager = context.importManager();

		String textFieldTableCellTypeName = importManager.useType(TextFieldTableCell.class);

		return
				  LS + "tableColumn -> "
				+ LS + "{"
				+ LS + "  " + textFieldTableCellTypeName
				+             "<"
				+                importManager.useType(clazz.getName())
				+                ", "
				+                importManager.useType(numericType)
				+             ">"
				+            " cell = new " + textFieldTableCellTypeName + "<>();"
				+ LS + "  " + "cell.setAlignment(" + importManager.useType(Pos.class) + ".CENTER_RIGHT);"
				+ LS + "  " + "return cell;"
				+ LS + "}"
			  ;
	}

	private boolean isPublicAndReturnsFXProperty(JavaMethod method)
	{
		return
				   isPublic(method)
		    && method.getReturnType().toErasure().isAssignableTo(Property.class)
				&& isCollection(method.getReturnType()) == false
				;
	}
}