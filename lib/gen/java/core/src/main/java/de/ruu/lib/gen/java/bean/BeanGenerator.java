package de.ruu.lib.gen.java.bean;

import static de.ruu.lib.gen.java.CompilationUnitFileWriter.writer;
import static de.ruu.lib.gen.java.GeneratorCodeBlock.codeBlokk;
import static de.ruu.lib.gen.java.Util.manageImports;
import static de.ruu.lib.gen.java.Visibility.PRIVATE;
import static de.ruu.lib.gen.java.Visibility.PUBLIC;
import static de.ruu.lib.gen.java.context.CompilationUnitContext.context;
import static de.ruu.lib.gen.java.doc.GeneratorJavaDoc.javaDoc;
import static de.ruu.lib.gen.java.element.GeneratorAnnotation.annotation;
import static de.ruu.lib.gen.java.element.GeneratorAnnotations.annotations;
import static de.ruu.lib.gen.java.element.GeneratorModifiers.modifiers;
import static de.ruu.lib.gen.java.element.GeneratorModifiersField.fieldModifiers;
import static de.ruu.lib.gen.java.element.GeneratorModifiersMethod.methodModifiers;
import static de.ruu.lib.gen.java.element.field.GeneratorField.field;
import static de.ruu.lib.gen.java.element.method.GeneratorMethod.method;
import static de.ruu.lib.util.Constants.LS;

import java.io.IOException;
import java.util.Comparator;
import java.util.Set;
import java.util.TreeSet;

import com.tngtech.archunit.core.domain.JavaClass;
import com.tngtech.archunit.core.domain.JavaMethod;

import de.ruu.lib.archunit.Util;
import de.ruu.lib.gen.GeneratorException;
import de.ruu.lib.gen.java.CompilationUnitFileWriter;
import de.ruu.lib.gen.java.GeneratorCodeBlock;
import de.ruu.lib.gen.java.context.CompilationUnitContext;
import de.ruu.lib.gen.java.element.GeneratorAnnotationParameter;
import de.ruu.lib.gen.java.element.GeneratorAnnotationParameters;
import de.ruu.lib.gen.java.element.type.GeneratorClass;
import de.ruu.lib.gen.java.element.type.GeneratorClassImplements;
import de.ruu.lib.gen.java.naming.ImportManager;
import de.ruu.lib.util.Time;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.NonNull;

/**
 * {@link BeanGenerator} produces java bean class for given {@link BeanGenerator#clazz}.
 *
 * TODO make use of lombok @Getter @Accessors(fluent = true)?
 */
public class BeanGenerator
{
	@NonNull private final String packageName;    // package name for target
	@NonNull private final String simpleFileName; // simple file name for target

	@NonNull private final JavaClass clazz;       // source
	
	@NonNull private CompilationUnitContext context;
	@NonNull private ImportManager          importManager;

	public BeanGenerator(
			@NonNull String packageName, @NonNull String simpleFileName, @NonNull JavaClass clazz)
	{
		this.packageName    = packageName;
		this.simpleFileName = simpleFileName;

		this.clazz          = clazz;
		
		context       = context(packageName, simpleFileName);
		importManager = context.importManager();
	}

	public void run() throws GeneratorException, IOException
	{
		GeneratorClass generator =
				GeneratorClass.classType(context, simpleFileName)
						.childNodesSeparator(LS)
						.javaDoc
						(
								javaDoc(context)
										.add("JavaBean {@link " + simpleFileName + "}")
										.add("<p>")
										.add("generated by {@link " + getClass().getName() + "} at " + Time.getSortableTimestamp())
						)
						.annotations
						(
								annotations(context)
										.childNodesSeparator(LS)
										.add(annotation(context, AllArgsConstructor.class))
										.add
										(
												annotation(context, Builder.class)
														.add
														(
																GeneratorAnnotationParameters.parameters(context)
																		.add
																		(
																				GeneratorAnnotationParameter.parameter
																				(
																						context,
																						"toBuilder",
																						"true"
																				)
																		)
														)
										)
						)
						.modifiers(modifiers(context).visibility(PUBLIC))
						.codeBlock(classCodeBlock())
						;
		if (clazz.isInterface())
		{
			generator
					.implementsClause
					(
							GeneratorClassImplements.implementsClause(context)
									.add(clazz.getName())
					);
		}
		CompilationUnitFileWriter writer = writer(packageName, simpleFileName);
		writer.write(generator.generate().toString());
	}

	private GeneratorCodeBlock classCodeBlock()
	{
		GeneratorCodeBlock result = codeBlokk(context).childNodesSeparator(LS);

		addGeneratorsForFields            (result);
		addGeneratorsForFluentStyleGetters(result);

		return result;
	}

	private void addGeneratorsForFields(GeneratorCodeBlock codeBlock)
	{
		// generate fields
		for (JavaMethod method : clazz.getAllMethods())
		{
			if (Util.isPublic(method))
			{
				codeBlock
						.add
						(
								field(context, type(method), name(method))
										.modifiers(fieldModifiers(context).visibility(PRIVATE))
						);
			}
		}
	}

	private void addGeneratorsForFluentStyleGetters(GeneratorCodeBlock codeBlock)
	{
		// generate methods
		Comparator<JavaMethod> methodNameComparator =
				(m1, m2) -> m1.getName().compareTo(m2.getName());
		Set<JavaMethod> methodsSortedByName =
				new TreeSet<>(methodNameComparator);
		methodsSortedByName.addAll(clazz.getAllMethods());

		for (JavaMethod method : methodsSortedByName)
		{
			if (Util.isPublic(method))
			{
				codeBlock
						// add child node separator before each getter
						.add(codeBlock.childNodesSeparator().toString())
						.add
						(
								method(context, type(method), name(method))
										.modifiers(methodModifiers(context).visibility(PUBLIC))
										.childNodesSeparator(LS)
										.codeBlock(codeBlokk(context).add("return " + name(method) + ";"))
						);
			}
		}
	}

	private String type(JavaMethod method)
	{
		return manageImports(method.getReturnType(), importManager).toString();
	}

	private String name(JavaMethod method)
	{
		return method.getName();
	}
}